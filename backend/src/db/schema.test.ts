import { test, expect, describe, beforeAll, afterAll } from 'bun:test'

import { db, connection } from './connection'
import { users, characters, characterStats, familyMembers, tasks, taskCompletions } from './schema'
import { eq } from 'drizzle-orm'

describe('Database Schema Integration Tests', () => {
  let testUserId: string
  let testCharacterId: string

  beforeAll(async () => {
    // Clean up any existing test data
    await db.delete(users).where(eq(users.email, 'test@schema.test'))
  })

  afterAll(async () => {
    // Clean up test data
    if (testUserId) {
      await db.delete(users).where(eq(users.id, testUserId))
    }
  })

  test('should create user with UUID primary key', async () => {
    const [user] = await db.insert(users).values({
      email: 'test@schema.test',
      name: 'Test User',
      timezone: 'UTC',
      zipCode: '12345',
    }).returning()

    testUserId = user.id

    expect(user.id).toMatch(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)
    expect(user.email).toBe('test@schema.test')
    expect(user.name).toBe('Test User')
    expect(user.timezone).toBe('UTC')
    expect(user.zipCode).toBe('12345')
    expect(user.createdAt).toBeInstanceOf(Date)
    expect(user.updatedAt).toBeInstanceOf(Date)
  })

  test('should create character with user relationship', async () => {
    const [character] = await db.insert(characters).values({
      userId: testUserId,
      name: 'Test Character',
      class: 'Test Explorer',
      backstory: 'A character created for testing purposes.',
      isActive: true,
    }).returning()

    testCharacterId = character.id

    expect(character.id).toMatch(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)
    expect(character.userId).toBe(testUserId)
    expect(character.name).toBe('Test Character')
    expect(character.class).toBe('Test Explorer')
    expect(character.isActive).toBe(true)
  })

  test('should create character stats with XP tracking', async () => {
    const [stat] = await db.insert(characterStats).values({
      characterId: testCharacterId,
      category: 'Test Skill',
      currentXp: 150,
      currentLevel: 2,
      totalXp: 250,
      description: 'A test skill for validation',
      sampleActivities: ['Test activity 1', 'Test activity 2'],
    }).returning()

    expect(stat.characterId).toBe(testCharacterId)
    expect(stat.category).toBe('Test Skill')
    expect(stat.currentXp).toBe(150)
    expect(stat.currentLevel).toBe(2)
    expect(stat.totalXp).toBe(250)
    expect(stat.sampleActivities).toEqual(['Test activity 1', 'Test activity 2'])
  })

  test('should create family members with interests', async () => {
    const [familyMember] = await db.insert(familyMembers).values({
      userId: testUserId,
      name: 'Test Family Member',
      age: 25,
      interests: ['reading', 'hiking', 'cooking'],
      interactionFrequency: 'weekly',
    }).returning()

    expect(familyMember.userId).toBe(testUserId)
    expect(familyMember.name).toBe('Test Family Member')
    expect(familyMember.age).toBe(25)
    expect(familyMember.interests).toEqual(['reading', 'hiking', 'cooking'])
    expect(familyMember.interactionFrequency).toBe('weekly')
  })

  test('should create tasks with multiple sources and status tracking', async () => {
    const [aiTask] = await db.insert(tasks).values({
      userId: testUserId,
      title: 'AI Generated Task',
      description: 'A task generated by AI',
      source: 'ai',
      targetStats: ['Test Skill'],
      estimatedXp: 50,
      status: 'pending',
    }).returning()

    expect(aiTask.source).toBe('ai')
    expect(aiTask.status).toBe('pending')
    expect(aiTask.targetStats).toEqual(['Test Skill'])
    expect(aiTask.estimatedXp).toBe(50)

    const [adHocTask] = await db.insert(tasks).values({
      userId: testUserId,
      title: 'Ad-hoc Task',
      description: 'A manually created task',
      source: 'ad-hoc',
      targetStats: ['Test Skill'],
      estimatedXp: 25,
      status: 'completed',
      completedAt: new Date(),
    }).returning()

    expect(adHocTask.source).toBe('ad-hoc')
    expect(adHocTask.status).toBe('completed')
    expect(adHocTask.completedAt).toBeInstanceOf(Date)
  })

  test('should create task completions with loose coupling design', async () => {
    // First create a task
    const [task] = await db.insert(tasks).values({
      userId: testUserId,
      title: 'Task for Completion Test',
      description: 'A task to test completion tracking',
      source: 'ad-hoc',
      targetStats: ['Test Skill'],
      estimatedXp: 30,
      status: 'completed',
      completedAt: new Date(),
    }).returning()

    // Then create a completion record
    const [completion] = await db.insert(taskCompletions).values({
      taskId: task.id,
      userId: testUserId,
      feedback: 'Great task completion!',
      actualXp: 35, // More XP than estimated
      statAwards: { 'Test Skill': 35 },
    }).returning()

    expect(completion.taskId).toBe(task.id)
    expect(completion.userId).toBe(testUserId)
    expect(completion.feedback).toBe('Great task completion!')
    expect(completion.actualXp).toBe(35)
    expect(completion.statAwards).toEqual({ 'Test Skill': 35 })
  })

  test('should handle timezone-aware timestamps correctly', async () => {
    const now = new Date()
    const [user] = await db.insert(users).values({
      email: 'timezone@test.com',
      name: 'Timezone Test',
    }).returning()

    // Check that timestamps are properly stored with timezone
    expect(user.createdAt).toBeInstanceOf(Date)
    expect(user.updatedAt).toBeInstanceOf(Date)
    
    // Verify the timestamps are close to when we created them (within 1 second)
    const timeDiff = Math.abs(user.createdAt.getTime() - now.getTime())
    expect(timeDiff).toBeLessThan(1000)

    // Clean up
    await db.delete(users).where(eq(users.id, user.id))
  })

  test('should enforce foreign key relationships', async () => {
    // Try to create a character with non-existent user ID
    const fakeUserId = '00000000-0000-4000-8000-000000000000'
    
    try {
      await db.insert(characters).values({
        userId: fakeUserId,
        name: 'Orphaned Character',
        class: 'Lost Soul',
      })
      // If we get here, the foreign key constraint didn't work
      expect(false).toBe(true)
    } catch (error) {
      // We expect this to throw a foreign key constraint error
      expect(error).toBeDefined()
    }
  })

  test('should cascade delete properly', async () => {
    // Create a temporary user
    const [tempUser] = await db.insert(users).values({
      email: 'cascade@test.com',
      name: 'Cascade Test',
    }).returning()

    // Create a character for this user
    const [tempCharacter] = await db.insert(characters).values({
      userId: tempUser.id,
      name: 'Temporary Character',
      class: 'Test Class',
    }).returning()

    // Create stats for this character
    await db.insert(characterStats).values({
      characterId: tempCharacter.id,
      category: 'Temporary Skill',
    })

    // Delete the user - should cascade to character and stats
    await db.delete(users).where(eq(users.id, tempUser.id))

    // Verify character was deleted
    const remainingCharacters = await db.select().from(characters).where(eq(characters.userId, tempUser.id))
    expect(remainingCharacters).toHaveLength(0)

    // Verify stats were deleted  
    const remainingStats = await db.select().from(characterStats).where(eq(characterStats.characterId, tempCharacter.id))
    expect(remainingStats).toHaveLength(0)
  })
})
